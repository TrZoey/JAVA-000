# 作业

## 01. 各种垃圾收集器的总结

#### Serial收集器
最基础，最历史悠久的收集器，采用标记-复制算法。早期新生代收集器的唯一选择。单线程工作，而且当进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束。
但他有简单高效的优点，而且是所有垃圾收集器中额外内存消耗最小的，是运行在客户端模式下的默认新生代收集器。另外对于单核处理器来说，单线程没有线程切换的开销，收集效率反而更高。它对于运行在客户端模式下（桌面应用）有着较好的应用。对于小内存的新生代来说，垃圾收集停顿时间完全可以控制在十几到几十毫秒。

#### Serial Old 收集器
Serial收集器的老年代版本。单线程。使用标记-整理算法。也是主要提供客户端模式下的虚拟机使用。在服务端也有使用：JDK5之前版本中搭配Parallel Scavenge收集器使用，还有就是作为CMS的备用收集器，并发收集发生Concurrent Mode Failure时使用。

#### ParNew收集器
Serial收集器的多线程版本，对于多核处理器来说，显然是要优于Serial收集器的。

#### Parallel Scavenge收集器
采用标记-复制算法的新生代收集器。多线程。关注的重点是达到一个可控制的吞吐量，又叫做吞吐量优先收集器。有参数可以设置为自动根据系统运行情况，设置合适的新生代大小、Eden与Survivor区域的比例、晋升老年代对象的大小等参数，来达到合适的停顿时间或者最大的吞吐量（自适应调节）。如果使用者对收集器手动优化存在困难，那么这个模式是一个不错的选择。

#### Parallel Od收集器
paralllel收集器的老年代版本。多线程。标记-整理算法。同样注重吞吐量。

#### CMS收集器
以最短回收停顿时间为目标，系统停顿时间尽量短来给用户最佳的交互体验。收集过程分为四个步骤：1. 初始标记 -> 2. 并发标记 -> 3. 重新标记 -> 4. 并发清除。初始标记和重新标记需要 Stop The World。初始标记只是标记一下GC Roots能直接关联到的对象，速度很快。并发标记是从GC Roots的直接关联对象开始遍历整个对象图的过程。重新标记是为了修正并发标记期间，用户线程继续运行导致的标记变动的一部分对象（增量更新），停顿时间稍长。最后是并发清除阶段。
但有三个明显的缺点：
1. CMS收集器对处理器资源非常敏感。占用了一部分CPU计算能力，所以导致总吞吐量降低。
2. 无法收集浮动垃圾有可能导致一次Full GC。并发标记和并发清除阶段，系统还是正常运行，所以需要预留出一部分内存来给系统使用。如果预留的内存无法满足程序新分配内存的需要，就会出现并发失败（Concurrent Mode Failure）。这时虚拟机会启用后备方案，冻结用户线程，临时启用Serial Old收集器来重新进行老年代的垃圾收集。这样会停顿更长的时间。
3. 因为是标记-清除算法，收集结束时会产生大量碎片空间。有时会提前出发Full GC。

#### Garbage First收集器
G1收集器。里程碑。开创了面向局部收集的思路和基于Region的内存布局形式。在延迟可控的情况下，获得尽可能高的吞吐量。
G1收集器将连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要扮演新生代的Eden空间，Survivor空间或者老年空间。还有一类Humongous区域，用来存储大对象，基本等同于老年代。
G1收集器会跟踪各个Region中垃圾的价值大小，即回收所获得的空间大小和回收所需要的时间。会根据价值维护一个优先级列表，每次根据用户设定的允许收集停顿时间，来优先回收价值最大的Region。保证了G1在有限的时间内获得尽可能高的收集效率。
每个Region会维护自己的记忆集，来解决跨Region引用问题。因此会占用更多的内存（堆内存的10%～20%）。
与CMS采用增量更新算法实现并发收集不同，G1采用原始快照算法实现。
收集过程：
-> 初始标记： 标记GC Roots能够直接关联到的对象
-> 并发标记 ：并发进行可达性分析
-> 最终标记 ：短暂停顿，处理并发标记结束时遗留的少量对象（原始快照）
-> 筛选回收：更新Region统计数据，根据价值和回收成本机型排序，并依据用户期望的停顿时间来制定回收计划。选择任意多个Region构成回收集，将存活的对象复制到空的Region中，在清除掉整个旧的Region空间。移动对象的过程必须暂停用户线程。并且由多条收集器线程并发执行。

#### G1对比CMS
根据经验，6-8G以下CMS更优，以上G1更优。未来G1会逐步甩开CMS。G1的内存占用和处理器负载都要高于CMS。而且现在也无法完全替代CMS的存在。


## 02. 写一段代码，使用 HttpClient 或 OkHttp 访问 http://localhost:8801
代码：[HttpDemo](work01/HttpDemo.java)